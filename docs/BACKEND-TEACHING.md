# بک‌اند رزرو — توضیح سادهٔ هر بخش

این سند به زبان ساده توضیح می‌دهد هر فایل و هر لایه برای **چی** است و **چطور** با بقیه وصل می‌شود.

---

## جریان کلی یک درخواست «ثبت رزرو»

```
فرانت Angular (Submit فرم)
    → درخواست POST به /api/bookings/ با بدنهٔ JSON (مثلاً originPort, destinationPort, ...)
    → Django: config/urls.py می‌گوید این آدرس را به apps.bookings.urls بده
    → apps/bookings/urls.py می‌گوید به BookingListCreateView بده
    → View: داده را به BookingSerializer می‌دهد؛ اگر معتبر بود serializer.save() را صدا می‌زند
    → Serializer.create(): سرویس create_booking را صدا می‌زند
    → Service: reference تولید می‌کند، یک Booking در دیتابیس می‌سازد و برمی‌گرداند
    → View: پاسخ را با _model_to_dict به camelCase تبدیل می‌کند و به فرانت برمی‌گرداند
```

یعنی: **View → Serializer → Service → Model (دیتابیس)**.

---

## ۱) مدل (models.py)

**چی هست؟** تعریف «جدول» رزرو در دیتابیس و ستون‌هایش.

**چرا؟** تا Django بداند چه فیلدهایی ذخیره کند (reference، تاریخ، بندر مبدا/مقصد، بار، وسیله، و غیره). هر بار که یک رزرو ساخته می‌شود، یک **ردیف** در این جدول اضافه می‌شود.

**نکته:** نام فیلدها در Django با **under_score** (مثل `origin_port`) است؛ در API و فرانت با **camelCase** (مثل `originPort`) صحبت می‌کنیم تا با Angular یکی باشد. تبدیل در سریالایزر و سرویس انجام می‌شود.

---

## ۲) سریالایزر (serializers.py)

**چی هست؟** پل بین «JSON که از فرانت می‌آید» و «مدل Django».

**چرا؟**
- ورودی را **اعتبارسنجی** می‌کند (مثلاً بندر مبدا/مقصد حتماً باشد، تاریخ معتبر باشد).
- دادهٔ معتبر را به لایهٔ سرویس می‌دهد تا رزرو ساخته شود.
- هنگام برگرداندن پاسخ، مدل را به **همان شکل فرانت** (camelCase) تبدیل می‌کند تا Angular راحت مصرف کند.

**نکته:** تابع `_model_to_dict` همان کاری را می‌کند که در فرانت انتظار داری: خروجی با `reference`, `createdAt`, `originPort`, `departureDate` و غیره.

---

## ۳) سرویس (services.py)

**چی هست؟** جایی که **منطق کسب‌وکار** است: «چطور یک رزرو ساخته شود» و «reference چطور یکتا تولید شود».

**چرا؟**
- View شلوغ نمی‌شود و فقط درخواست/پاسخ را جابه‌جا می‌کند.
- اگر بعداً همان «ساخت رزرو» را از جای دیگری (مثلاً یک دستور مدیریتی یا یک تسک) بخواهی، همان تابع `create_booking` را صدا می‌زنی.
- تولید reference و تبدیل نام فیلدها (camel → snake) اینجا انجام می‌شود.

**نکته:** تابع `_ensure_unique_reference()` مطمئن می‌شود شمارهٔ رزرو تکراری نباشد.

---

## ۴) ویو (views.py)

**چی هست؟** دریافت درخواست HTTP (GET یا POST) و برگرداندن پاسخ مناسب.

**چرا؟**
- **POST /api/bookings/** → بدنه را به سریالایزر می‌دهد؛ اگر معتبر بود با `serializer.save()` رزرو ساخته می‌شود و پاسخ با reference و createdAt برمی‌گردد.
- **GET /api/bookings/** → لیست رزروها (فعلاً همه؛ بعداً می‌توانی فیلتر کنی).
- **GET /api/bookings/<reference>/** → جزئیات یک رزرو.

**نکته:** `AllowAny` یعنی فعلاً بدون لاگین هم می‌شود درخواست زد؛ وقتی JWT وصل شد می‌توانی برای بعضی آدرس‌ها `IsAuthenticated` بگذاری.

---

## ۵) آدرس‌ها (urls.py)

**چی هست؟** تعیین می‌کند هر **آدرس** به کدام **View** برود.

- `/api/bookings/` → `BookingListCreateView` (GET لیست، POST ساخت)
- `/api/bookings/SC-xxx-01/` → `BookingDetailView` (GET جزئیات)

در `config/urls.py` با `include('apps.bookings.urls')` زیرمجموعهٔ آدرس‌ها را به اپ bookings وصل کرده‌ایم.

---

## ۶) ادمین (admin.py)

**چی هست؟** ثبت مدل `Booking` در پنل ادمین تا از صفحهٔ `/admin/` بتوانی رزروها را ببینی، جستجو کنی و در صورت نیاز ویرایش کنی.

**چرا؟** برای مدیریت دستی و بررسی داده بدون نوشتن کد جدا.

---

## خلاصهٔ نقش هر لایه

| لایه      | نقش ساده |
|-----------|-----------|
| **Model** | تعریف جدول و فیلدها در دیتابیس |
| **Serializer** | اعتبارسنجی ورودی + تبدیل مدل به خروجی JSON (camelCase) |
| **Service** | منطق ساخت رزرو و تولید reference |
| **View** | دریافت درخواست، صدا زدن سریالایزر/سرویس، برگرداندن پاسخ |
| **URLs** | مسیریابی آدرس به View |
| **Admin** | نمایش و مدیریت رزروها در پنل ادمین |

---

## تست سریع

۱. سرور Django را اجرا کن: `python manage.py runserver`
۲. Angular را اجرا کن و از فرم Registration یک رزرو ثبت کن.
۳. باید در پاسخ، `reference` و `createdAt` از سمت بک بیاید و در لیست Cargo list نمایش داده شود.
۴. از پنل ادمین (`/admin/`) هم می‌توانی همان رزرو را در جدول «رزروها» ببینی.

اگر خطایی دیدی (مثلاً ۴۰۰ برای validation یا ۵۰۰ برای باگ)، در کنسول سرور Django متن خطا را می‌بینی تا بتوانی رفعش کنی.
